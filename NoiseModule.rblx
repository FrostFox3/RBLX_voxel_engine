--!native
--!strict
--!optimize 2

--[[ MATH ]]
local min = math.min
local max = math.max
local abs = math.abs
local floor = math.floor
local pi:number = 355/113

--[[ VECTOR ]]
local v3n = vector.create
local v3f = vector.floor
local v3d = vector.dot
local v31:vector = vector.one
local F3v:vector = (math.sqrt(4)-1)/3 *vector.one
local G3v:vector = (1-1/math.sqrt(4))/3 *vector.one
local v3x:vector = v3n(1,0,0)
local v3y:vector = v3n(0,1,0)
local v3z:vector = v3n(0,0,1)

--[[ BIT32 ]]
local bxor = bit32.bxor
local band = bit32.band
local bor = bit32.bor
local btest = bit32.btest
local bnot = bit32.bnot
local lshift = bit32.lshift
local rshift = bit32.rshift
local lrotate = bit32.lrotate
local rrotate = bit32.rrotate

local hash32_11_ = function (x:number,size:number):number
	x=bxor(x,rshift(x,16))*0x21f0aaad
	x=bxor(x,rshift(x,15))*0x735a2d97
	if size then
		return band(bxor(x,rshift(x,15)),size)
	else
		return bxor(x,rshift(x,15))
	end
end
local hash32_31_ = function (p:vector,size:number):number
	local hash:number=8+bxor(p.x,rshift(p.x,16))*0x21f0aaad
	hash=bxor(hash,rshift(hash,15))*0x735a2d97
	hash=bxor(hash,rshift(hash,15))
	hash+=bxor(p.y,rshift(p.y,16))*0x21f0aaad
	hash=bxor(hash,rshift(hash,15))*0x735a2d97
	hash=bxor(hash,rshift(hash,15))
	hash+=bxor(p.z,rshift(p.z,16))*0x21f0aaad
	hash=bxor(hash,rshift(hash,15))*0x735a2d97
	hash=bxor(hash,rshift(hash,15))
	hash=bxor(hash,rshift(hash,16))*0x21f0aaad
	hash=bxor(hash,rshift(hash,15))*0x735a2d97
	if size then
		return band(bxor(hash,rshift(hash,15)),size)
	else
		return bxor(hash,rshift(hash,15))
	end
end
local hash32_33_ = function (p:vector,size:number):vector
	-- x : y,z,seed
	-- y : x,z,seed
	-- z : x,y,seed
	local x:number,y:number,z:number=p.x,p.y,p.z

	x,y,z=bit32.bxor(bit32.rshift(x,8),y)*0x41C64E6D,bit32.bxor(bit32.rshift(y,8),z)*0x41C64E6D,bit32.bxor(bit32.rshift(z,8),x)*0x41C64E6D
	x,y,z=bit32.bxor(bit32.rshift(x,8),y)*0x41C64E6D,bit32.bxor(bit32.rshift(y,8),z)*0x41C64E6D,bit32.bxor(bit32.rshift(z,8),x)*0x41C64E6D
	x,y,z=bit32.bxor(bit32.rshift(x,8),y)*0x41C64E6D,bit32.bxor(bit32.rshift(y,8),z)*0x41C64E6D,bit32.bxor(bit32.rshift(z,8),x)*0x41C64E6D

	if size then
		return v3n(band(x,size),band(y,size),band(z,size))
	else
		return v3n(x,y,z)
	end
end
local sides:{[number]:vector} = { -- 26
	v3n(-1,1,-1),v3n(0,1,-1),v3n(1,1,-1),
	v3n(-1,0,-1),v3n(0,0,-1),v3n(1,0,-1),
	v3n(-1,-1,-1),v3n(0,-1,-1),v3n(1,-1,-1),

	v3n(-1,1,0),v3n(0,1,0),v3n(1,1,0),
	v3n(-1,0,0),                        v3n(1,0,0),
	v3n(-1,-1,0),v3n(0,-1,0),v3n(1,-1,0),

	v3n(-1,1,1),v3n(0,1,1),v3n(1,1,1),
	v3n(-1,0,1),v3n(0,0,1),v3n(1,0,1),
	v3n(-1,-1,1),v3n(0,-1,1),v3n(1,-1,1)
}
-- 0xFFFF : 4bytes = 2^16; 0xFFFFFFFF : 8bytes = 2^32
local HEX16:number = 0xFFFF
local HEX32:number = 0xFFFFFFFF

--input a position and a seed and get a noise output
local simplex=function(p:vector,seed:vector):number
	local s:vector=v3f(p+v31*v3d(p,F3v))
	local x:vector=p-s+v31*v3d(s,G3v)
	local e:vector=v3n(x.x-x.y>=0 and 1 or 0,x.y-x.z>=0 and 1 or 0,x.z-x.x>=0 and 1 or 0)
	e=v3n(e.x,e.y,min(e.z,3-(e.x+e.y+e.z)))
	local i1:vector=e*(v31-v3n(e.z,e.x,e.y))
	local i2:vector=v31-v3n(e.z,e.x,e.y)*(v31-e)
	local x1:vector=x-i1+G3v
	local x2:vector=x-i2+2*G3v
	local x3:vector=x-v31+3*G3v
	local w1:number = max(.6-(x.x*x.x+x.y*x.y+x.z*x.z),0) -- 0.6-x^2
	local w2:number = max(.6-(x1.x*x1.x+x1.y*x1.y+x1.z*x1.z),0)
	local w3:number = max(.6-(x2.x*x2.x+x2.y*x2.y+x2.z*x2.z),0)
	local w4:number = max(.6-(x3.x*x3.x+x3.y*x3.y+x3.z*x3.z),0)
	return w1*w1*w1*w1*v3d(sides[floor(hash32_31_(s+seed,HEX16)/HEX16*25)+1],x)*52+w2*w2*w2*w2*v3d(sides[floor(hash32_31_(s+i1+seed,HEX16)/HEX16*25)+1],x1)*52+w3*w3*w3*w3*v3d(sides[floor(hash32_31_(s+i2+seed,HEX16)/HEX16*25)+1],x2)*52+w4*w4*w4*w4*v3d(sides[floor(hash32_31_(s+v31+seed,HEX16)/HEX16*25)+1],x3)*52
end
local worley=function(p:vector,s:vector):number
	local ipos:vector = v3f(p)
	local Distances_Raw:{[number]:vector}={
		hash32_33_(ipos+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[1]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[2]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[3]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[4]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[5]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[6]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[7]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[8]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[9]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[10]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[11]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[12]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[13]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[14]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[15]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[16]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[17]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[18]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[19]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[20]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[21]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[22]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[23]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[24]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[25]+s,HEX16)/HEX16+ipos-p,
		hash32_33_(ipos+sides[26]+s,HEX16)/HEX16+ipos-p
	}
	return min(
		Distances_Raw[1].x*Distances_Raw[1].x+Distances_Raw[1].y*Distances_Raw[1].y+Distances_Raw[1].z*Distances_Raw[1].z,
		Distances_Raw[2].x*Distances_Raw[2].x+Distances_Raw[2].y*Distances_Raw[2].y+Distances_Raw[2].z*Distances_Raw[2].z,
		Distances_Raw[3].x*Distances_Raw[3].x+Distances_Raw[3].y*Distances_Raw[3].y+Distances_Raw[3].z*Distances_Raw[3].z,
		Distances_Raw[4].x*Distances_Raw[4].x+Distances_Raw[4].y*Distances_Raw[4].y+Distances_Raw[4].z*Distances_Raw[4].z,
		Distances_Raw[5].x*Distances_Raw[5].x+Distances_Raw[5].y*Distances_Raw[5].y+Distances_Raw[5].z*Distances_Raw[5].z,
		Distances_Raw[6].x*Distances_Raw[6].x+Distances_Raw[6].y*Distances_Raw[6].y+Distances_Raw[6].z*Distances_Raw[6].z,
		Distances_Raw[7].x*Distances_Raw[7].x+Distances_Raw[7].y*Distances_Raw[7].y+Distances_Raw[7].z*Distances_Raw[7].z,
		Distances_Raw[8].x*Distances_Raw[8].x+Distances_Raw[8].y*Distances_Raw[8].y+Distances_Raw[8].z*Distances_Raw[8].z,
		Distances_Raw[9].x*Distances_Raw[9].x+Distances_Raw[9].y*Distances_Raw[9].y+Distances_Raw[9].z*Distances_Raw[9].z,
		Distances_Raw[10].x*Distances_Raw[10].x+Distances_Raw[10].y*Distances_Raw[10].y+Distances_Raw[10].z*Distances_Raw[10].z,
		Distances_Raw[11].x*Distances_Raw[11].x+Distances_Raw[11].y*Distances_Raw[11].y+Distances_Raw[11].z*Distances_Raw[11].z,
		Distances_Raw[12].x*Distances_Raw[12].x+Distances_Raw[12].y*Distances_Raw[12].y+Distances_Raw[12].z*Distances_Raw[12].z,
		Distances_Raw[13].x*Distances_Raw[13].x+Distances_Raw[13].y*Distances_Raw[13].y+Distances_Raw[13].z*Distances_Raw[13].z,
		Distances_Raw[14].x*Distances_Raw[14].x+Distances_Raw[14].y*Distances_Raw[14].y+Distances_Raw[14].z*Distances_Raw[14].z,
		Distances_Raw[15].x*Distances_Raw[15].x+Distances_Raw[15].y*Distances_Raw[15].y+Distances_Raw[15].z*Distances_Raw[15].z,
		Distances_Raw[16].x*Distances_Raw[16].x+Distances_Raw[16].y*Distances_Raw[16].y+Distances_Raw[16].z*Distances_Raw[16].z,
		Distances_Raw[17].x*Distances_Raw[17].x+Distances_Raw[17].y*Distances_Raw[17].y+Distances_Raw[17].z*Distances_Raw[17].z,
		Distances_Raw[18].x*Distances_Raw[18].x+Distances_Raw[18].y*Distances_Raw[18].y+Distances_Raw[18].z*Distances_Raw[18].z,
		Distances_Raw[19].x*Distances_Raw[19].x+Distances_Raw[19].y*Distances_Raw[19].y+Distances_Raw[19].z*Distances_Raw[19].z,
		Distances_Raw[20].x*Distances_Raw[20].x+Distances_Raw[20].y*Distances_Raw[20].y+Distances_Raw[20].z*Distances_Raw[20].z,
		Distances_Raw[21].x*Distances_Raw[21].x+Distances_Raw[21].y*Distances_Raw[21].y+Distances_Raw[21].z*Distances_Raw[21].z,
		Distances_Raw[22].x*Distances_Raw[22].x+Distances_Raw[22].y*Distances_Raw[22].y+Distances_Raw[22].z*Distances_Raw[22].z,
		Distances_Raw[23].x*Distances_Raw[23].x+Distances_Raw[23].y*Distances_Raw[23].y+Distances_Raw[23].z*Distances_Raw[23].z,
		Distances_Raw[24].x*Distances_Raw[24].x+Distances_Raw[24].y*Distances_Raw[24].y+Distances_Raw[24].z*Distances_Raw[24].z,
		Distances_Raw[25].x*Distances_Raw[25].x+Distances_Raw[25].y*Distances_Raw[25].y+Distances_Raw[25].z*Distances_Raw[25].z,
		Distances_Raw[26].x*Distances_Raw[26].x+Distances_Raw[26].y*Distances_Raw[26].y+Distances_Raw[26].z*Distances_Raw[26].z
		)^.5
end
local SminCircular = function (a:number,b:number,k:number):number
	k*=pi
	local h:number=max(k-(a-b>=0 and a-b or -a+b),0)/k
	return min(a,b)-k*.5*(1+h-(1-h*(h-2))^.5)
end
local Numberworley=function(p:vector,s:vector):number
	local ipos:vector = v3f(p)
	local d = hash32_33_(ipos-s,HEX16)/HEX16+ipos-p
	local dist:number=d.x*d.x+d.y*d.y+d.z*d.z
	local r:number=hash32_31_(ipos,HEX16)/HEX16
	for _:number,v:vector in ipairs(sides) do
		d=hash32_33_(ipos+v-s,HEX16)/HEX16+ipos+v-p
		if d.x*d.x+d.y*d.y+d.z*d.z<dist then
			dist=d.x*d.x+d.y*d.y+d.z*d.z
			r=hash32_31_(ipos+v,HEX16)/HEX16
		end
	end
	return r,dist^.5
end
local SmoothF1worley=function(p:vector,smoothness:number,s:vector):number
	local ipos:vector = v3f(p)
	local d:vector=hash32_33_(ipos-s,HEX16)/HEX16+ipos-p
	--local r:number=hash32_31_(ipos-s,HEX16)/HEX16
	local dist:number=d.x*d.x+d.y*d.y+d.z*d.z
	local h:number
	for _:number,v:vector in ipairs(sides) do
		d=hash32_33_(ipos+v-s,HEX16)/HEX16+ipos+v-p
		dist=SminCircular(dist,d.x*d.x+d.y*d.y+d.z*d.z,(dist-d.x*d.x+d.y*d.y+d.z*d.z)/smoothness)
	end
	return dist^.5
end

local module = {}

module.worley=worley
module.Numberworley=Numberworley
module.SmoothF1worley=SmoothF1worley

module.simplex=simplex

module.hash32_11_=hash32_11_
module.hash32_31_=hash32_31_
module.hash32_33_=hash32_33_

module.seed = game.ServerStorage.Seed

module.ChunkBlockPadding={}
module.ChunkBlockPosition={}
for x:number=1,16,1 do -- 16^3
	for y:number=1,16,1 do
		for z:number=1,16,1 do
			module.ChunkBlockPosition[#module.ChunkBlockPosition+1]=v3n(x,y,z)
		end
	end
end
--warn(#module.ChunkBlockPosition)

return module
